# Rules for QC and initial annotation of genomic DNAseq reads

import glob # Needed for functions below

rule quast_spades_k127_comb:
    # Quality metrics of combined assembly
    input:
        expand("assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",sp=config['species'],qtrimvals=config['qtrimvals'])
    output:
        "qc/quast_spades_k127_comb/report.html"
    threads: 16
    conda: "envs/quast.yml"
    log: "logs/quast_spades_k127_comb_{wildcards.sp}_q{wildcards.qtrimvals}.log"
    shell:
        "quast.py -o qc/quast_spades_k127_comb -t {threads} -m 500 -s -L --large {input} &> {log}"

def get_spades_multiple_input_corr_reads_fwd(wildcards):
    r1=glob.glob("assembly/spades-comb_"+wildcards.sp+"_q"+wildcards.qtrimvals+"/corrected/*_R12_ktrim_qtrim"+wildcards.qtrimvals+"_1.00.*_0.cor.fastq.gz")
    r1.sort()
    return r1

def get_spades_multiple_input_corr_reads_rev(wildcards):
    r2=glob.glob("assembly/spades-comb_"+wildcards.sp+"_q"+wildcards.qtrimvals+"/corrected/*_R12_ktrim_qtrim"+wildcards.qtrimvals+"_2.00.*_0.cor.fastq.gz")
    r2.sort()
    return r2

rule bbmap_covstats_spades_comb:
    # Coverage stats of combined assembly, required for GC-coverage plot
    input:
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",
        cor_fwd=get_spades_multiple_input_corr_reads_fwd,
        cor_rev=get_spades_multiple_input_corr_reads_rev
    output:
        "annotation/spades-comb_{sp}_q{qtrimvals}/spades-comb_{sp}_q{qtrimvals}.scaffolds.covstats"
    threads: 16
    conda: "envs/bbmap.yml"
    log: "logs/bbmap_covstats.spades-comb_{sp}_q{qtrimvals}.log"
    params:
        inarg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_fwd(wildcards)),
        in2arg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_rev(wildcards))
    shell:
        "bbwrap.sh -Xmx24g threads={threads} fast=t nodisk minid=0.98 ref={input.scaffolds} in={params.inarg} in2={params.in2arg} covstats={output} &> {log}"

rule bbmap_covstats:
    # Coverage stats of individual assemblies, required for GC-coverage plot
    input:
        scaffolds="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta",
        cor_fwd="assembly/{assembler}_{lib}_q{qtrimvals}/corrected/{lib}_R12_ktrim_qtrim{qtrimvals}_1.00.0_0.cor.fastq.gz",
        cor_rev="assembly/{assembler}_{lib}_q{qtrimvals}/corrected/{lib}_R12_ktrim_qtrim{qtrimvals}_2.00.0_0.cor.fastq.gz"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.scaffolds.covstats"
    wildcard_constraints:
        assembler="[^_]+(?<!comb)" # Negate underscore character so that the assembler and lib wildcards are split properly, negative lookbehind for 'comb' to avoid applying this rule to combined assemblies
    threads: 16
    conda: "envs/bbmap.yml"
    log: "logs/bbmap_covstats.{assembler}_{lib}_q{qtrimvals}.log"
    shell:
        "bbmap.sh -Xmx60g threads={threads} fast=t nodisk minid=0.98 ref={input.scaffolds} in={input.cor_fwd} in2={input.cor_rev} covstats={output} &> {log};"
        "sed -i 's/^#//' {output};" # Strip leading # from header line

rule bowtie_build_spades_comb:
    # Build bowtie database of combined assembly, required for mapping
    input:
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta"
    output:
        "annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.1.bt2"
    conda: "envs/bowtie2.yml"
    threads: 16
    log: "logs/bowtie_build_spades_comb.{sp}_q{qtrimvals}.log"
    params:
        prefix="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}",
        seed=12345
    shell:
        "touch annotation/spades-comb_{wildcards.sp}_q{wildcards.qtrimvals}/mapping/DO_NOT_BACKUP_THIS_FOLDER;"
        "bowtie2-build --threads {threads} --seed {params.seed} {input.scaffolds} {params.prefix} &> {log}"

rule bowtie_build_indiv:
    # Build bowtie database of individual assembly, required for mapping
    input:
        scaffolds="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.1.bt2"
    conda: "envs/bowtie2.yml"
    wildcard_constraints:
        assembler="[^_]+(?<!comb)" # Negate underscore character so that the assembler and lib wildcards are split properly, negative lookbehind for 'comb' to avoid applying this rule to combined assemblies
    threads: 16
    log: "logs/bowtie_build_indiv.{assembler}.{lib}_q{qtrimvals}.log"
    params:
        prefix="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}",
        seed=12345
    shell:
        "touch annotation/{wildcards.assembler}_{wildcards.lib}_q{wildcards.qtrimvals}/mapping/DO_NOT_BACKUP_THIS_FOLDER;"
        "bowtie2-build --threads {threads} --seed {params.seed} {input.scaffolds} {params.prefix} &> {log}"

rule bowtie_map_spades_comb:
    # Map combined assembly with bowtie2
    input:
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",
        bt2_index1="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.1.bt2",
        cor_fwd=get_spades_multiple_input_corr_reads_fwd,
        cor_rev=get_spades_multiple_input_corr_reads_rev
    output:
        bam="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.bam",
        bamsort="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.sort.bam"
    log: "logs/bowtie_map_spades_comb.{sp}_q{qtrimvals}.log"
    threads: 16
    conda: "envs/bowtie2.yml"
    params:
        prefix="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}",
        inarg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_fwd(wildcards)),
        in2arg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_rev(wildcards))
    shell:
        "bowtie2 --very-fast --no-unal --threads {threads} -x {params.prefix} -1 {params.inarg} -2 {params.in2arg} | samtools view -bS > {output.bam};"
        "samtools sort --threads 16 -o {output.bamsort} --reference {input.scaffolds} {output.bam};"

rule bowtie_map_indiv:
    # Map individual assembly with bowtie2
    input:
        # scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",
        scaffolds="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta",
        bt2_index1="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.1.bt2",
        cor_fwd="assembly/{assembler}_{lib}_q{qtrimvals}/corrected/{lib}_R12_ktrim_qtrim{qtrimvals}_1.00.0_0.cor.fastq.gz",
        cor_rev="assembly/{assembler}_{lib}_q{qtrimvals}/corrected/{lib}_R12_ktrim_qtrim{qtrimvals}_2.00.0_0.cor.fastq.gz"
        # cor_fwd=get_spades_multiple_input_corr_reads_fwd,
        # cor_rev=get_spades_multiple_input_corr_reads_rev
    output:
        bam="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.bam",
        bamsort="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.sort.bam"
    log: "logs/bowtie_map_indiv.{assembler}.{lib}_q{qtrimvals}.log"
    threads: 16
    conda: "envs/bowtie2.yml"
    wildcard_constraints:
        assembler="[^_]+(?<!comb)" # Negate underscore character so that the assembler and lib wildcards are split properly, negative lookbehind for 'comb' to avoid applying this rule to combined assemblies
    params:
        prefix="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}"
        # inarg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_fwd(wildcards)),
        # in2arg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_rev(wildcards))
    shell:
        "bowtie2 --very-fast --no-unal --threads {threads} -x {params.prefix} -1 {input.cor_fwd} -2 {input.cor_rev} | samtools view -bS > {output.bam};"
        "samtools sort --threads 16 -o {output.bamsort} --reference {input.scaffolds} {output.bam};"

rule bowtie_map_spades_comb_samtools_depth:
    # Get coverage from sorted BAM file of bowtie2 mapping reads to combined metagenomic assemblies
    input:
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",
        bamsort="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.sort.bam"
    output:
        "annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.bt2.depth"
    log: "logs/bowtie_map_spades_comb_samtools_depth.{sp}_q{qtrimvals}.log"
    threads: 2
    conda: "envs/bowtie2.yml"
    shell:
        "samtools depth -a --reference {input.scaffolds} -o {output} {input.bamsort} &> {log}"

rule bowtie_map_indiv_samtools_depth:
    # Get coverage from sorted BAM file of bowtie2 mapping reads to combined metagenomic assemblies
    input:
        scaffolds="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta",
        bamsort="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.sort.bam"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.bt2.depth"
    log: "logs/bowtie_map_indiv_samtools_depth.{assembler}.{lib}_q{qtrimvals}.log"
    threads: 2
    conda: "envs/bowtie2.yml"
    wildcard_constraints:
        assembler="[^_]+(?<!comb)" # Negate underscore character so that the assembler and lib wildcards are split properly, negative lookbehind for 'comb' to avoid applying this rule to combined assemblies
    shell:
        "samtools depth -a --reference {input.scaffolds} -o {output} {input.bamsort} &> {log}"

rule bowtie_map_spades_comb_covstats:
    # Convert samtools depth file to covstats-like file
    input:
        depth="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.bt2.depth",
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta"
    output:
        "annotation/spades-comb_{sp}_q{qtrimvals}/spades-comb_{sp}_q{qtrimvals}.bt2.covstats"
    log: "logs/bowtie_map_spades_comb_covstats.{sp}_q{qtrimvals}.log"
    threads: 2
    shell:
        "python3 code/samtools_depth_to_covstats.py --depth {input.depth} --fasta {input.scaffolds} --out {output} --log {log}"

rule bowtie_map_indiv_covstats:
    # Convert samtools depth file to covstats-like file
    input:
        depth="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.bt2.depth",
        scaffolds="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.bt2.covstats"
    log: "logs/bowtie_map_indiv_covstats.{assembler}.{lib}_q{qtrimvals}.log"
    threads: 2
    wildcard_constraints:
        assembler="[^_]+(?<!comb)" # Negate underscore character so that the assembler and lib wildcards are split properly, negative lookbehind for 'comb' to avoid applying this rule to combined assemblies
    shell:
        "python3 code/samtools_depth_to_covstats.py --depth {input.depth} --fasta {input.scaffolds} --out {output} --log {log}"

rule plot_bt2_covstats_cdsdens:
    # Blob plot of metagenome assembly using covstats from Bowtie2, colored by CDS density
    input:
        covstats="annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.bt2.covstats",
        cdsdens="annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.cds-dens.tsv"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.bt2.blobplot.png"
    threads: 2
    shell: 
        "Rscript code/blobplot.R --covstats {input.covstats} --cdsdens {input.cdsdens} --out {output}"

rule barrnap:
    # Screen assembly for rRNA genes
    input:
        "assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta"
    output:
        gff="annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.barrnap.{kingdom}.gff",
        fasta="annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.barrnap.{kingdom}.fasta"
    conda: "envs/barrnap.yml"
    threads: 4
    log: "logs/barrnap.{assembler}_{lib}_q{qtrimvals}.{kingdom}.log"
    shell:
        "barrnap --kingdom {wildcards.kingdom} --threads {threads} {input} > {output.gff} 2> {log};"
        "bedtools getfasta -fi {input} -bed {output.gff} -fo {output.fasta} 2>> {log}"

rule bandage_rrna_draw:
    # From assembly graph draw contigs connected to identified rRNA sequences
    # to see if bacterial genomes/contigs can be pulled out
    input:
        fastg="assembly/{assembler}_{lib}_q{qtrimvals}/assembly_graph.fastg",
        barrnap_fasta="annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.barrnap.{kingdom}.fasta"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.barrnap.{kingdom}.Bandage.png"
    conda: "envs/bandage.yml"
    threads: 1
    log: "logs/bandage_rrna_draw.{assembler}_{lib}_q{qtrimvals}.{kingdom}.log"
    shell:
        "Bandage image {input.fastg} {output} --query {input.barrnap_fasta} --scope aroundblast --distance 5 &> {log}"

rule mt_rrna_hmm:
    # Scan for ciliate mt rRNA sequences using custom HMM
    input:
        "assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta"
    output:
        out="annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.{rrnagene}.nhmmer.out",
        tblout="annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.{rrnagene}.nhmmer.tblout"
    conda: "envs/barrnap.yml"
    log: "logs/mt_rrna_hmm.{assembler}_{lib}_q{qtrimvals}.{rrnagene}.log"
    params:
        hmm="resources/mt_rRNA_hmm/ciliate_{rrnagene}.hmm"
    threads: 4
    shell:
        "nhmmer --cpu {threads} --tblout {output.tblout} {params.hmm} {input} > {output.out} 2> {log}"

rule prodigal_for_cds_dens:
    input:
        "assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.prodigal.gff"
    conda: "envs/prodigal.yml"
    threads: 16
    shell:
        "cat {input} | parallel --gnu -j {threads} --recstart '>' -N 100 --pipe prodigal -f gff -p meta -g 11 > {output}"

rule calculate_cds_dens:
    input:
        assembly="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta",
        gff="annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.prodigal.gff"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.cds-dens.tsv"
    params:
        prefix="annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}"
    shell:
        "perl code/bin_by_coding_density.pl --in {input.assembly} --gff {input.gff} --out {params.prefix} --no-fasta"
