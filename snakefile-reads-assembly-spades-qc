# Rules for QC and initial annotation of genomic DNAseq reads

import glob # Needed for functions below

rule quast_spades_k127_comb:
    # Quality metrics of combined assembly
    input:
        expand("assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",sp=config['species'],qtrimvals=config['qtrimvals'])
    output:
        "qc/quast_spades_k127_comb/report.html"
    threads: 16
    conda: "envs/quast.yml"
    log: "logs/quast_spades_k127_comb_{wildcards.sp}_q{wildcards.qtrimvals}.log"
    shell:
        "quast.py -o qc/quast_spades_k127_comb -t {threads} -m 500 -s -L --large {input} &> {log}"

def get_spades_multiple_input_corr_reads_fwd(wildcards):
    r1=glob.glob("assembly/spades-comb_"+wildcards.sp+"_q"+wildcards.qtrimvals+"/corrected/*_R12_ktrim_qtrim"+wildcards.qtrimvals+"_1.00.*_0.cor.fastq.gz")
    r1.sort()
    return r1

def get_spades_multiple_input_corr_reads_rev(wildcards):
    r2=glob.glob("assembly/spades-comb_"+wildcards.sp+"_q"+wildcards.qtrimvals+"/corrected/*_R12_ktrim_qtrim"+wildcards.qtrimvals+"_2.00.*_0.cor.fastq.gz")
    r2.sort()
    return r2

rule bbmap_covstats_spades_comb:
    # Coverage stats of combined assembly, required for GC-coverage plot
    input:
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",
        cor_fwd=get_spades_multiple_input_corr_reads_fwd,
        cor_rev=get_spades_multiple_input_corr_reads_rev
    output:
        "annotation/spades-comb_{sp}_q{qtrimvals}/spades-comb_{sp}_q{qtrimvals}.scaffolds.covstats"
    threads: 16
    conda: "envs/bbmap.yml"
    log: "logs/bbmap_covstats.spades-comb_{sp}_q{qtrimvals}.log"
    params:
        inarg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_fwd(wildcards)),
        in2arg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_rev(wildcards))
    shell:
        "bbwrap.sh -Xmx24g threads={threads} fast=t nodisk minid=0.98 ref={input.scaffolds} in={params.inarg} in2={params.in2arg} covstats={output} &> {log}"

rule bbmap_covstats:
    # Coverage stats of individual assemblies, required for GC-coverage plot
    input:
        scaffolds="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta",
        cor_fwd="assembly/{assembler}_{lib}_q{qtrimvals}/corrected/{lib}_R12_ktrim_qtrim{qtrimvals}_1.00.0_0.cor.fastq.gz",
        cor_rev="assembly/{assembler}_{lib}_q{qtrimvals}/corrected/{lib}_R12_ktrim_qtrim{qtrimvals}_2.00.0_0.cor.fastq.gz"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/{assembler}_{lib}_q{qtrimvals}.scaffolds.covstats"
    wildcard_constraints:
        assembler="[^_]+(?<!comb)" # Negate underscore character so that the assembler and lib wildcards are split properly, negative lookbehind for 'comb' to avoid applying this rule to combined assemblies
    threads: 16
    conda: "envs/bbmap.yml"
    log: "logs/bbmap_covstats.{assembler}_{lib}_q{qtrimvals}.log"
    shell:
        "bbmap.sh -Xmx60g threads={threads} fast=t nodisk minid=0.98 ref={input.scaffolds} in={input.cor_fwd} in2={input.cor_rev} covstats={output} &> {log};"
        "sed -i 's/^#//' {output};" # Strip leading # from header line

rule bowtie_build_spades_comb:
    # Build bowtie database of combined assembly, required for mapping
    input:
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta"
    output:
        "annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.1.bt2"
    conda: "envs/bowtie2.yml"
    threads: 16
    log: "logs/bowtie_build_spades_comb.{sp}_q{qtrimvals}.log"
    params:
        prefix="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}",
        seed=12345
    shell:
        "touch annotation/spades-comb_{wildcards.sp}_q{wildcards.qtrimvals}/mapping/DO_NOT_BACKUP_THIS_FOLDER;"
        "bowtie2-build --threads {threads} --seed {params.seed} {input.scaffolds} {params.prefix} &> {log}"

rule bowtie_build_indiv:
    # Build bowtie database of individual assembly, required for mapping
    input:
        scaffolds="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.1.bt2"
    conda: "envs/bowtie2.yml"
    wildcard_constraints:
        assembler="[^_]+(?<!comb)" # Negate underscore character so that the assembler and lib wildcards are split properly, negative lookbehind for 'comb' to avoid applying this rule to combined assemblies
    threads: 16
    log: "logs/bowtie_build_indiv.{assembler}.{lib}_q{qtrimvals}.log"
    params:
        prefix="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}",
        seed=12345
    shell:
        "touch annotation/{wildcards.assembler}_{wildcards.lib}_q{wildcards.qtrimvals}/mapping/DO_NOT_BACKUP_THIS_FOLDER;"
        "bowtie2-build --threads {threads} --seed {params.seed} {input.scaffolds} {params.prefix} &> {log}"

rule bowtie_map_spades_comb:
    # Map combined assembly with bowtie2
    input:
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",
        bt2_index1="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.1.bt2",
        cor_fwd=get_spades_multiple_input_corr_reads_fwd,
        cor_rev=get_spades_multiple_input_corr_reads_rev
    output:
        bam="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.bam",
        bamsort="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.sort.bam"
    log: "logs/bowtie_map_spades_comb.{sp}_q{qtrimvals}.log"
    threads: 16
    conda: "envs/bowtie2.yml"
    params:
        prefix="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}",
        inarg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_fwd(wildcards)),
        in2arg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_rev(wildcards))
    shell:
        "bowtie2 --very-fast --no-unal --threads {threads} -x {params.prefix} -1 {params.inarg} -2 {params.in2arg} | samtools view -bS > {output.bam};"
        "samtools sort --threads 16 -o {output.bamsort} --reference {input.scaffolds} {output.bam};"

rule bowtie_map_indiv:
    # Map individual assembly with bowtie2
    input:
        # scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",
        scaffolds="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta",
        bt2_index1="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.1.bt2",
        cor_fwd="assembly/{assembler}_{lib}_q{qtrimvals}/corrected/{lib}_R12_ktrim_qtrim{qtrimvals}_1.00.0_0.cor.fastq.gz",
        cor_rev="assembly/{assembler}_{lib}_q{qtrimvals}/corrected/{lib}_R12_ktrim_qtrim{qtrimvals}_2.00.0_0.cor.fastq.gz"
        # cor_fwd=get_spades_multiple_input_corr_reads_fwd,
        # cor_rev=get_spades_multiple_input_corr_reads_rev
    output:
        bam="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.bam",
        bamsort="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.sort.bam"
    log: "logs/bowtie_map_indiv.{assembler}.{lib}_q{qtrimvals}.log"
    threads: 16
    conda: "envs/bowtie2.yml"
    wildcard_constraints:
        assembler="[^_]+(?<!comb)" # Negate underscore character so that the assembler and lib wildcards are split properly, negative lookbehind for 'comb' to avoid applying this rule to combined assemblies
    params:
        prefix="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}"
        # inarg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_fwd(wildcards)),
        # in2arg=lambda wildcards: ','.join(get_spades_multiple_input_corr_reads_rev(wildcards))
    shell:
        "bowtie2 --very-fast --no-unal --threads {threads} -x {params.prefix} -1 {input.cor_fwd} -2 {input.cor_rev} | samtools view -bS > {output.bam};"
        "samtools sort --threads 16 -o {output.bamsort} --reference {input.scaffolds} {output.bam};"

rule bowtie_map_spades_comb_samtools_depth:
    # Get coverage from sorted BAM file of bowtie2 mapping reads to combined metagenomic assemblies
    input:
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta",
        bamsort="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.sort.bam"
    output:
        "annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.bt2.depth"
    log: "logs/bowtie_map_spades_comb_samtools_depth.{sp}_q{qtrimvals}.log"
    threads: 2
    conda: "envs/bowtie2.yml"
    shell:
        "samtools depth -a --reference {input.scaffolds} -o {output} {input.bamsort} &> {log}"

rule bowtie_map_indiv_samtools_depth:
    # Get coverage from sorted BAM file of bowtie2 mapping reads to combined metagenomic assemblies
    input:
        scaffolds="assembly/{assembler}_{lib}_q{qtrimvals}/scaffolds.fasta",
        bamsort="annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.sort.bam"
    output:
        "annotation/{assembler}_{lib}_q{qtrimvals}/mapping/{assembler}_{lib}_q{qtrimvals}.bt2.depth"
    log: "logs/bowtie_map_indiv_samtools_depth.{assembler}.{lib}_q{qtrimvals}.log"
    threads: 2
    conda: "envs/bowtie2.yml"
    wildcard_constraints:
        assembler="[^_]+(?<!comb)" # Negate underscore character so that the assembler and lib wildcards are split properly, negative lookbehind for 'comb' to avoid applying this rule to combined assemblies
    shell:
        "samtools depth -a --reference {input.scaffolds} -o {output} {input.bamsort} &> {log}"

rule bowtie_map_spades_comb_covstats:
    # Convert samtools depth file to covstats-like file
    input:
        depth="annotation/spades-comb_{sp}_q{qtrimvals}/mapping/spades-comb_{sp}_q{qtrimvals}.bt2.depth",
        scaffolds="assembly/spades-comb_{sp}_q{qtrimvals}/scaffolds.fasta"
    output:
        "annotation/spades-comb_{sp}_q{qtrimvals}/spades-comb_{sp}_q{qtrimvals}.bt2.covstats"
    log: "logs/bowtie_map_spades_comb_covstats.{sp}_q{qtrimvals}.log"
    threads: 2
    shell:
        "python3 code/samtools_depth_to_covstats.py --depth {input.depth} --fasta {input.scaffolds} --out {output} --log {log}"
